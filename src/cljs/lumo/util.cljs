(ns lumo.util
  (:require-macros lumo.util)
  (:require [clojure.string :as string]
            [cljs.compiler :as comp]
            [cljs.reader :as edn]))

(def fs (js/require "fs"))
(def node-path (js/require "path"))
(def crypto (js/require "crypto"))

;; next line is auto-generated by the build-script - Do not edit!
;(def ^:dynamic *clojurescript-version*)

(defn ^String clojurescript-version
  "Returns clojurescript version as a printable string."
  []
  cljs.core/*clojurescript-version*
  #_(if-not (nil? *clojurescript-version*)
    (str
     (:major *clojurescript-version*)
     "."
     (:minor *clojurescript-version*)
     (when-let [i (:incremental *clojurescript-version*)]
       (str "." i))
     (when-let [q (:qualifier *clojurescript-version*)]
       (str "." q))
     (when (:interim *clojurescript-version*)
       "-SNAPSHOT"))
    "0.0.0000"))

(defn compiled-by-version [f]
  #_(with-open [reader (io/reader f)]
    (let [match (->> reader line-seq first
                     (re-matches #".*ClojureScript (\d+\.\d+\.\d+).*$"))]
      (or (and match (second match)) "0.0.0000"))))

(defn distinct-by
  ([f coll]
   (let [step (fn step [xs seen]
                (lazy-seq
                  ((fn [[x :as xs] seen]
                     (when-let [s (seq xs)]
                       (let [v (f x)]
                         (if (contains? seen v)
                           (recur (rest s) seen)
                           (cons x (step (rest s) (conj seen v)))))))
                    xs seen)))]
     (step coll #{}))))

(defn output-directory
  ([opts] (output-directory opts "out"))
  ([opts default]
   {:pre [(or (nil? opts) (map? opts))]}
   (or (:output-dir opts) default)))

(defn debug-prn
  [& args]
  (binding [*print-fn* *print-err-fn*]
    (apply println args)))

(defn directory? [path]
  (try
    (.isDirectory (fs.lstatSync path))
    (catch :default _
      false)))

(defn mkdirs [p]
  (let [target-dir (-> p node-path.resolve (node-path.resolve ".."))]
    (reduce (fn [acc d]
              (let [new-path (node-path.join acc d)]
                (println "dir" d new-path)
                (cond-> new-path
                  (not (fs.existsSync new-path))
                  fs.mkdirSync)
                new-path))
      "/" (rest (string/split target-dir #"/")))))

(defn last-modified [path]
  (.getTime (.-mtime (fs.statSync path))))

(defn changed? [a b]
  (not (== (last-modified a) (last-modified b))))

(defn munge-path [ss]
  (comp/munge (str ss)))

(defn ns->relpath
  "Given a namespace as a symbol return the relative path. May optionally
  provide the file extension, defaults to :cljs."
  ([ns] (ns->relpath ns :cljs))
  ([ns ext]
   (str (string/replace (munge-path ns) \. \/) "." (name ext))))

(defn path [x]
  {:pre [(string? x)]}
  (node-path.resolve x))

(defn ext
  "Given a file, url or string return the file extension."
  [x]
  {:pre [(string? x)]}
  (last (string/split x #"\.")))

(defn path-seq
  [file-str]
  ;; TODO: need to quote path-sep?
  (->> (.-sep node-path)
       re-pattern
       (string/split file-str)))

(defn to-path
  ([parts]
     (to-path parts (.-sep node-path)))
  ([parts sep]
    (apply str (interpose sep parts))))

(defn get-name
  "Given a file or url return the last component of the path."
  [x]
  (last (string/split (path x) #"/")))

(defn relative-name
  "Given a file return a path relative to the working directory. Given a
   URL return the JAR relative path of the resource."
  [x]
  (letfn [(strip-user-dir [s]
            (string/replace s
              (str (js/process.cwd) (.-sep node-path)) ""))]
    ;; TODO: distinguish between JAR / normal file
    #_(if (file? x)
      (strip-user-dir (.getAbsolutePath x))
      (let [f (.getFile x)]
        (if (string/includes? f ".jar!/")
          (last (string/split f #"\.jar!/"))
          (strip-user-dir f))))))

(defn content-sha [s]
  (let [digest (crypto.createHash "sha1")]
    (.update digest s)
    (.toUppserCase (.digest digest "hex"))))

(defn line-seq [path]
  (string/split (fs.readFileSync path) #"\n"))

(defn build-options [f]
  (let [reader f]
    (let [match (->> reader line-seq first
                  (re-matches #".*ClojureScript \d+\.\d+\.\d+ (.*)$"))]
      (and match (edn/read-string (second match))))))

(defn map-merge [a b]
  (if (and (map? a) (map? b))
    (loop [ks (seq (keys a)) ret a b' b]
      (if ks
        (let [k (first ks)]
          (if (contains? b' k)
            (recur
              (next ks)
              (assoc ret k (map-merge (get ret k) (get b' k)))
              (dissoc b' k))
            (recur (next ks) ret b')))
        (merge ret b')))
    a))

(defn file-seq [dir]
  (tree-seq
    (fn [f] (.isDirectory (.statSync fs f) ()))
    (fn [d] (map #(.join node-path d %) (.readdirSync fs d)))
    dir))


(defn to-target-file
  ([target-dir ns-info]
   (to-target-file target-dir ns-info "js"))
  ([target-dir {:keys [ns source-file] :as ns-info} ext]
   (let [src-ext (if source-file
                   (lumo.util/ext source-file)
                   "cljs")
         ns      (if (or (= src-ext "clj")
                       (and (= ns 'cljs.core) (= src-ext "cljc")))
                   (symbol (str ns "$macros"))
                   ns)
         relpath (string/split (munge-path (str ns)) #"\.")
         parents (cond-> (butlast relpath)
                   target-dir (conj target-dir))]
     (cond->> (node-path.join (str (last relpath) (str "." ext)))
       (seq parents)
       (to-path parents)))))
